def lcm(x, y):
    greater = 0
    if x > y:
        greater = x
    else:
        greater = y

    while (True):
        if (greater % x == 0 and greater % y == 0):
            break
        greater = greater + 1
    return greater


# hcf and GCD
def gcd(x, y):
    smaller = 0

    if x < y:
        smaller = x
    else:
        smaller = y
    i = 1
    while i < smaller + 1:
        if((x % i == 0) and (y % i == 0)):
            return i

g = gcd(10,12)
l = lcm(24, 54)
print(l)
print(g)




### Single Linkedlist

# Define the Node class
class Node:
    def __init__(self, data):
        self.data = data  # Node data
        self.next = None  # Pointer to the next node (initially None)

# Define the LinkedList class
class LinkedList:
    def __init__(self):
        self.head = None  # Initially, the list is empty (head is None)
    
    # Method to append a new node to the linked list
    def append(self, data):
        new_node = Node(data)  # Create a new node with the given data
        if not self.head:
            self.head = new_node  # If the list is empty, set head to the new node
        else:
            last = self.head
            while last.next:  # Traverse to the last node
                last = last.next
            last.next = new_node  # Set the last node's next to the new node
    
    # Method to display the linked list
    def display(self):
        current = self.head
        while current:
            print(current.data, end=" -> ")
            current = current.next
        print("None")  # End of list
    
    # Method to search for a value in the linked list
    def search(self, value):
        current = self.head
        while current:
            if current.data == value:
                return True  # Value found
            current = current.next
        return False  # Value not found
    
    # Method to delete a node with a given value
    def delete(self, value):
        current = self.head
        # If the list is empty
        if not current:
            return
        
        # If the head node itself holds the value to be deleted
        if current.data == value:
            self.head = current.next  # Change head to the next node
            current = None  # Free memory
            return
        
        # Find the previous node of the node to be deleted
        prev = None
        while current and current.data != value:
            prev = current
            current = current.next
        
        # If the value wasn't found
        if not current:
            print(f"Value {value} not found in the list.")
            return
        
        # Unlink the node from the linked list
        prev.next = current.next
        current = None  # Free memory

# Example usage
ll = LinkedList()
ll.append(10)
ll.append(20)
ll.append(30)
ll.append(40)

# Display the linked list
ll.display()  # Output: 10 -> 20 -> 30 -> 40 -> None

# Search for a value
print("Is 20 in the list?", ll.search(20))  # Output: True
print("Is 50 in the list?", ll.search(50))  # Output: False

# Delete a node
ll.delete(20)
ll.display()  # Output: 10 -> 30 -> 40 -> None
